
def inorder(n, V):  # V는 마지막 정점
    global cnt  # 노드에 작성할 값
    if n <= V: # 유효한 노드이면
        inorder(n*2, V) # 왼쪽 자식 이동
        cnt += 1
        tree[n] = cnt # 값 기록 (정점 번호 작성)
        inorder(n*2+1, V) # 오르쪽 자식 이동

for tc in range(1, int(input())+1):
    N = int(input())
    tree = [0] * (N + 1) # 비어있는 이진트리 생성
    cnt = 0
    inorder(1, N)
    print(f'#{tc} {tree[1]} {tree[N//2]}')


'''
def inorder(n, V):  #V는 마지막 정점 번호
    global cnt
    if n <= V:   #n이 유효한 노드이면 (예를 들어 4*2는 8이니까 마지막정점번호를 초과 > 이런것은 버리겠다) 3*2는 6은 있으니 가고, 3*2+1은 없음, 오른쪽자식은  없으 거름(3번은)
        #계속 들어가다가 위 if를 만족못하면 리턴. 예를들어 8번정점 없을 경우'리턴'
        inorder(n*2, V)    #왼쪽자식으로 이동
        #왼쪽에서 리턴해오면
        cnt += 1    # 처리할 정점의 개수가 한 개 더 늘어남
        tree[n] = cnt  #최종적으로 저장하려는 모양은.. #값 기록  #내가 지금 방문한 트리의 n에(tree[n]) 정점 번호를 써주면 됨.
        #tree[n]에 카운트값을 넣어주고, 오른쪽자식으로 이동.
        inorder(n*2+1, V)  #오른쪽자식으로 이동
 
 
T = int(input())
for tc in range(1, T+1):
 
    N = int(input())
    #1. 비어있는 완전이진트리 하나 만들기
    tree = [0] *(N+1)   #비어있는 완전이진트리 생성/ 완전이진트리는 N번까지 있는.
    #루트가 1이고
    #         1
    #     2      3
    #   4   5   6
    #아래로 내려가면서 왼쪽부터 번호가 붙는, 0 1 2 3 4 5 6 이 배열이 만들어짐
 
    #이제 숫자 들어가는 거에 맞춰서 중위순회를 할 것
    cnt = 0
    inorder(1, N)   #1번정점부터 가고 총 N개의 정점이 있음.
    print(f'#{tc} {tree[1]} {tree[N//2]}')   #tree의 N//2번 정점에 있는 값을  출력!
    #완전이진트리이니까 루트는 무조건 1번.
 
    #빈 트리에 값을 채우는 것 역시 순회를 이용!!
'''