'''
짝수, 홀수 검사하기
####### a 연산 결과########
  0 0 0 0 0 0 1 0
& 0 0 0 0 0 0 0 1  -> 밑이 1 이면 위의 비트가 반영됨
___________________
                0  -> 0 번비트만 검사하면 짝수인지 홀수인지 알 수 있다.
                   -> 0 이면 짝수
______&___  -> 논리연산 and
0 0  \  0
0 1  \  0
1 0  \  0
1 1  \  1

####### b 연산결과#########
  0 0 0 0 0 0 1 1
& 0 0 0 0 0 0 0 1
------------------
                1  -> 0이 아님 ( 홀수)

'''
'''
# if a % 2 == 0:
#     print('짝수')

a = 102
b = 331
c = 331

print(a&1)  # 0 -> 짝수
print(b&1)  # 1 -> 홀수
# 짝수 홀수 판단 가능
if a & 0x01: # 0이 아니면
    print('홀수')
else:
    print('짝수')

# xor 연산
print(a^b) # 다르기 때문에 0이 아닌 값
print(b^c) # 같으면 0

# 1. 비트 반전
# 2. 비교

if b == c:
    print('같음')

if b^c == 0:
    print('같음')
'''
####### xor 연산 예제 #######
# a배열에서 b의 원소를 인덱스로 0->1, 1->0 바꾸기

a = [1, 0, 0, 1, 1, 0, 0, 0]
b = [0, 1, 2, 7]

# 1. 원래대로면 이렇게 판별해서 할 수 있음
# for i in b:
#     if a[i]:
#         a[i] = 0
#     else:
#         a[i] = 1

# 2. xor 비트연산으로 변경하기 -> 특정 비트가 있는 값을 변경시킬 수 있다.
for i in b:
    a[i] ^= 1
print(a)


'''
비트연산 sample
(i&(1<<2))>>2

  0 0 1 0
& 0 1 0 0
----------
 0 1 0 0  != 0
여기서 1을 오른쪽으로 2칸 옮겨서 b0으로 보내기 (>>2)
-> 그렇다면 1이 출력 되게 된다.
-> 2 번 비트의 값 (b2)를 >>2 해서 (b0)으로 옮긴 후 print 하는 것

'''

# for i in range(1 << 3):
#     # if i & (1<<0): # 0 번비트만 검사
#     #     print(f'{i}의 0번 비트는 1')
#     # else:
#     #     print(f'{i}의 0번 비트는 0')
#     print(f'{i}의 2번 비트는{(i&(1<<2))>>2}')